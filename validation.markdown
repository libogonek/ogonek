---
layout: default
title: Validation
---

When errors are found encoding or decoding streams, there are various ways of
dealing with the errors. Ogonek provides four different error-handling
strategies. Functions that take a validation strategy argument can often be
called without the strategy argument; when that happens
`ogonek::throw_validation_error` is the default used.

All validation strategies are objects declared in the header
`<ogonek/validation.h++>`.

---

#### `throw_validation_error`

This strategy throws a `ogonek::validation_error` whenever invalid data is
found.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::throw_validation_error };
// throws since s is not a valid UTF-8 sequence
// (it has an unfinished multi-byte sequence)
{% endhighlight %}

---

#### `discard_errors`

This strategy discards any invalid data and proceeds as if it was not present in
the stream.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::discard_errors };
// the unfinished multi-byte sequence is discarded
// t ends up with u8"banana"
{% endhighlight %}

---

#### `use_replacement_character`

This strategy replaces invalid data with a replacement character. If the
encoding of the output stream supports it, the Unicode replacement character
U+FFFD
&#640;&#7431;&#7448;&#671;&#7424;&#7428;&#7431;&#7437;&#7431;&#628;&#7451;
&#7428;&#668;&#7424;&#640;&#7424;&#7428;&#7451;&#7431;&#640;. is used. Otherwise
an encoding specific character (given by the encoding `replacement_character`
member, often `?` U+003F &#491;&#7452;&#7431;s&#7451;&#618;&#7439;&#628;
&#7437;&#7424;&#640;&#7435;) is used.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::use_replacement_character };
// the unfinished multi-byte sequence is replaced with U+FFFD
// t ends up with u8"bana\uFFFDna"
{% endhighlight %}

---

#### `skip_validation`

This strategy assumes the stream is valid and performs no validation. This is
useful when the stream is known to be good, for example, if it was validated
previously, or generated by a process that cannot generate invalid data. If used
on a stream with invalid data, the behaviour is undefined.

*Bad Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::skip_validation };
// the unfinished multi-byte sequence is ignored
// this results in undefined behaviour
{% endhighlight %}

*Good Example*:
{% highlight cpp %}
std::string s = u8"banana"; // we know for sure that s is valid
ogonek::text<ogonek::utf8> t { s, ogonek::skip_validation };
{% endhighlight %}

---

### See Also

- [Encoding](encoding.html)

